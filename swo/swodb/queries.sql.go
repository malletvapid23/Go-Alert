// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: queries.sql

package swodb

import (
	"context"
	"time"
)

const activeTxCount = `-- name: ActiveTxCount :one
SELECT COUNT(*)
FROM pg_stat_activity
WHERE "state" <> 'idle'
    AND "xact_start" <= $1
`

func (q *Queries) ActiveTxCount(ctx context.Context, xactStart time.Time) (int64, error) {
	row := q.db.QueryRow(ctx, activeTxCount, xactStart)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const changes = `-- name: Changes :many
SELECT id,
    table_name,
    row_id
FROM change_log
`

func (q *Queries) Changes(ctx context.Context) ([]ChangeLog, error) {
	rows, err := q.db.Query(ctx, changes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeLog
	for rows.Next() {
		var i ChangeLog
		if err := rows.Scan(&i.ID, &i.TableName, &i.RowID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const currentSwitchoverState = `-- name: CurrentSwitchoverState :one
SELECT current_state
FROM switchover_state
`

func (q *Queries) CurrentSwitchoverState(ctx context.Context) (EnumSwitchoverState, error) {
	row := q.db.QueryRow(ctx, currentSwitchoverState)
	var current_state EnumSwitchoverState
	err := row.Scan(&current_state)
	return current_state, err
}

const currentSwitchoverStateNoWait = `-- name: CurrentSwitchoverStateNoWait :one
SELECT current_state
FROM switchover_state NOWAIT
`

func (q *Queries) CurrentSwitchoverStateNoWait(ctx context.Context) (EnumSwitchoverState, error) {
	row := q.db.QueryRow(ctx, currentSwitchoverStateNoWait)
	var current_state EnumSwitchoverState
	err := row.Scan(&current_state)
	return current_state, err
}

const currentTime = `-- name: CurrentTime :one
SELECT now()::timestamptz
`

func (q *Queries) CurrentTime(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRow(ctx, currentTime)
	var column_1 time.Time
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteChanges = `-- name: DeleteChanges :exec
DELETE FROM change_log
WHERE id = ANY($1)
`

func (q *Queries) DeleteChanges(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteChanges, id)
	return err
}

const foreignKeys = `-- name: ForeignKeys :many
SELECT src.relname::text,
    dst.relname::text
FROM pg_catalog.pg_constraint con
    JOIN pg_catalog.pg_namespace ns ON ns.nspname = 'public'
    AND ns.oid = con.connamespace
    JOIN pg_catalog.pg_class src ON src.oid = con.conrelid
    JOIN pg_catalog.pg_class dst ON dst.oid = con.confrelid
WHERE con.contype = 'f'
    AND NOT con.condeferrable
`

type ForeignKeysRow struct {
	SrcRelname string
	DstRelname string
}

func (q *Queries) ForeignKeys(ctx context.Context) ([]ForeignKeysRow, error) {
	rows, err := q.db.Query(ctx, foreignKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForeignKeysRow
	for rows.Next() {
		var i ForeignKeysRow
		if err := rows.Scan(&i.SrcRelname, &i.DstRelname); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const globalSwitchoverExecLock = `-- name: GlobalSwitchoverExecLock :one
SELECT pg_try_advisory_lock(4370)
FROM switchover_state
WHERE current_state != 'use_next_db'
`

func (q *Queries) GlobalSwitchoverExecLock(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, globalSwitchoverExecLock)
	var pg_try_advisory_lock bool
	err := row.Scan(&pg_try_advisory_lock)
	return pg_try_advisory_lock, err
}

const globalSwitchoverSharedConnLock = `-- name: GlobalSwitchoverSharedConnLock :exec
SELECT pg_advisory_lock_shared(4369)
`

func (q *Queries) GlobalSwitchoverSharedConnLock(ctx context.Context) error {
	_, err := q.db.Exec(ctx, globalSwitchoverSharedConnLock)
	return err
}

const globalSwitchoverTxExclusiveConnLock = `-- name: GlobalSwitchoverTxExclusiveConnLock :exec
SELECT pg_advisory_xact_lock(4369)
`

func (q *Queries) GlobalSwitchoverTxExclusiveConnLock(ctx context.Context) error {
	_, err := q.db.Exec(ctx, globalSwitchoverTxExclusiveConnLock)
	return err
}

const lastLogID = `-- name: LastLogID :one
SELECT COALESCE(MAX(id), 0)::bigint
FROM switchover_log
`

func (q *Queries) LastLogID(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, lastLogID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const logEvents = `-- name: LogEvents :many
SELECT id,
    TIMESTAMP,
    DATA
FROM switchover_log
WHERE id > $1
ORDER BY id ASC
LIMIT 100
`

func (q *Queries) LogEvents(ctx context.Context, id int64) ([]SwitchoverLog, error) {
	rows, err := q.db.Query(ctx, logEvents, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SwitchoverLog
	for rows.Next() {
		var i SwitchoverLog
		if err := rows.Scan(&i.ID, &i.Timestamp, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sequenceNames = `-- name: SequenceNames :many
SELECT sequence_name
FROM information_schema.sequences
WHERE sequence_catalog = current_database()
    AND sequence_schema = 'public'
    AND sequence_name != 'change_log_id_seq'
`

func (q *Queries) SequenceNames(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, sequenceNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var sequence_name string
		if err := rows.Scan(&sequence_name); err != nil {
			return nil, err
		}
		items = append(items, sequence_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tableColumns = `-- name: TableColumns :many
SELECT col.table_name,
    col.column_name,
    col.data_type,
    col.ordinal_position
FROM information_schema.columns col
    JOIN information_schema.tables t ON t.table_catalog = col.table_catalog
    AND t.table_schema = col.table_schema
    AND t.table_name = col.table_name
    AND t.table_type = 'BASE TABLE'
WHERE col.table_catalog = current_database()
    AND col.table_schema = 'public'
`

func (q *Queries) TableColumns(ctx context.Context) ([]InformationSchemaColumn, error) {
	rows, err := q.db.Query(ctx, tableColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InformationSchemaColumn
	for rows.Next() {
		var i InformationSchemaColumn
		if err := rows.Scan(
			&i.TableName,
			&i.ColumnName,
			&i.DataType,
			&i.OrdinalPosition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlockAll = `-- name: UnlockAll :exec
SELECT pg_advisory_unlock_all()
`

func (q *Queries) UnlockAll(ctx context.Context) error {
	_, err := q.db.Exec(ctx, unlockAll)
	return err
}
